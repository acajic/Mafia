class ActionType::Revive < ActionType

  # actions of this type cannot be submitted manually
  # instead, they are generated by actions of type ActionType::InitiateRevival

  KEY_TARGET_ID = 'target_id'

  def before_creation
    super
    self.trigger_id = Trigger::DAY_START
    @default_params = action_type_params()
    self.default_params_json = @default_params.to_json()

    self.name = 'Revive'
    self.action_result_type_id = ActionResultType::REVIVAL_OCCURRED
    self.can_submit_manually = false
    true
  end

  PARAM_DAYS_UNTIL_REVEAL = 'days_until_reveal'
  PARAM_LIFETIME_ACTIONS_COUNT = 'number_of_actions_available'

  def action_type_params
    {
        # default one day until it is revealed what resident is revived
        PARAM_DAYS_UNTIL_REVEAL => 1,
        PARAM_LIFETIME_ACTIONS_COUNT => 1
    }
  end

  def params_valid(action_type_params)
    if action_type_params.nil?
      return true
    end

    days_until_reveal_param = action_type_params[PARAM_DAYS_UNTIL_REVEAL]

    number_of_actions_available = action_type_params[PARAM_LIFETIME_ACTIONS_COUNT]
    days_until_reveal_param.is_a?(Numeric) && number_of_actions_available.is_a?(Numeric) && number_of_actions_available>0
  end

  def action_valid?(action, action_type_params_per_resident_role_action_type)
    actions_available(action, action_type_params_per_resident_role_action_type)
  end

  def create_valid_action_results(actions, city)
    logger.info('MANUAL LOG - ' + self.class.name + '#' + __method__.to_s())

    if actions.nil? || actions.empty?
      return nil
    end

    logger.info('MANUAL LOG - action not empty')

    actions_per_resident = Action.latest_action_per_resident(actions)

    logger.info('MANUAL LOG - actions per resident')

    action_results = []
    actions_per_resident.each_pair { |resident, action|

      logger.info('MANUAL LOG - processing action performed by resident ' + resident.id.to_s())

      target_id = action.input[KEY_TARGET_ID]
      if target_id == resident.id
        # necromancer cannot revive himself
        next
      end
      target_resident = city.residents.where(:id => target_id).first()
      if target_resident.nil?
        # unknown resident targeted
        next
      end
      if target_resident.alive
        # cannot revive resident that is already alive
        next
      end


      ResidentPreviousRole.create(:resident_id => target_resident.id, :previous_role_id => target_resident.role_id, :day_id => city.current_day(false).id)
      target_resident.alive = true
      target_resident.role_id = Role::ZOMBIE
      target_resident.saved_role_id = Role::ZOMBIE
      target_resident.save()

      days_until_reveal = action.action_type_params.action_type_params_hash[ActionType::Revive::PARAM_DAYS_UNTIL_REVEAL]

      action_results << {:action => action,
                         :action_result_type_id => self.action_result_type_id,
                         :city_id => resident.city_id,
                         :resident_id => nil,
                         :role_id => nil,
                         # no need to set :day property, it is being set from Module::City::DayCycleHandler using Module::ActionResult::StoreResults
                         :result => { self.action_result_type.class::KEY_DAYS_UNTIL_REVEAL => days_until_reveal },
                         :is_automatically_generated => true}
    }


    logger.info('MANUAL LOG - returning action results')

    action_results #return array of ActionResult init hashes
  end

  def create_void_action_results(actions, city)
    logger.info('MANUAL LOG - ' + self.class.name + '#' + __method__.to_s())

    # do nothing on void Revive
    nil
  end


  private

  def actions_available(action, action_type_params_per_resident_role_action_type)
    resident_role_action_type_params = nil
    if action_type_params_per_resident_role_action_type[action.resident_id].nil? ||
        action_type_params_per_resident_role_action_type[action.resident_id][action.role_id].nil? ||
        action_type_params_per_resident_role_action_type[action.resident_id][action.role_id][action.action_type_id].nil?
      resident_role_action_type_params = ResidentRoleActionTypeParamsModel.create(:resident_id => action.resident_id, :role_id => action.role_id, :action_type_id => action.action_type_id)
    else
      resident_role_action_type_params = action_type_params_per_resident_role_action_type[action.resident_id][action.role_id][action.action_type_id]
    end


    if resident_role_action_type_params.action_type_params_hash[PARAM_LIFETIME_ACTIONS_COUNT] < 0
      return true # negative value interpreted as infinite
    end

    actions_available = resident_role_action_type_params.action_type_params_hash[PARAM_LIFETIME_ACTIONS_COUNT] > 0
    actions_available
  end

end